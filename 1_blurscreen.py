#Research code by Simon Kraatz USDA (simon.kraatz@usda.gov)
#LAI, step 1: Purpose is to pre-screen upward looking camera data (JPG) for blurryness. Method is Variance of Laplacian. This is needed because it is common for water to be on lens. 

#DISCLAIMER: The USDA-ARS makes no warranties as to the merchantability or fitness of this research code for any particular purpose, or any other warranties expressed or implied. Since some portions of this code have been validated with only limited data sets, it should not be used to make operational management decisions. The USDA-ARS is not liable for any damages resulting from the use or misuse of this code its output and its accompanying documentation.

####-------------------HEADER-----------------####
import os, argparse
import imageio.v2 as imageio
import numpy as np
import pandas as pd
from datetime import datetime
from skimage.color import rgb2gray
from skimage.filters import laplace
from skimage.transform import rescale
from scipy.ndimage import variance
from skimage.util import img_as_ubyte

####-------------------USER_SPECIFY-----------------####
#see argparse
####-------------------FUNC/METH-----------------####
def cmdLineParse():
    '''
    Command line parser.
    '''
    parser = argparse.ArgumentParser( description='Screen JPG data by modify timestamp. Example: python 0_hourscreen.py -i 401cam')
    parser.add_argument('-i', '--indir', dest='indir', type=str, required=True,
                        help='The input directory where the .JPG and .csv of step 0 are. Output is a .csv listing images passing the screen.')
    parser.add_argument('-s', '--skipbotpix', dest='skipbotpix', type=int, required=False, default=100,
                        help='Specify the number of pixels to truncate from image bottom (phenocam has some text rather than image data). Default = 100')
    parser.add_argument('-c', '--scaleimg', dest='scaleimg', type=float, required=False, default=0.25,
                        help='Scale image by this factor to speed up blur detection. Default = 0.25.')
    parser.add_argument('-v', '--varthr', dest='b1thr', type=float, required=False, default = 0.010,
                        help='Require image to exceed a variance threshold to not be omitted. Default is 0.010.')
    parser.add_argument('-m', '--maxthr', dest='b2thr', type=float, required=False, default = 1.080,
                        help='Require image to exceed an absolute maximum value to not be omitted. Default is 1.080.')
    parser.add_argument('-p', '--printoutp', dest='printoutp', type=int, required=False, default = 0,
                        help='Print output for each image processed (=1). Default is 0.')
    parser.add_argument('-f', '--filtering', dest='filtering', type=int, required=False, default = 1,
                        help='Filter image according to -v and -m input (=1), or dont filter at all (=0). Default is 1. Use of (=0) is to get b1thr, b2thr for all hourscreened images written to csv, potentially for manual subsetting & optimizing the thr values.')
    return parser.parse_args()

####-------------------PROGRAM-----------------####
def blurscreen(indir, scaleimg, b1thr, b2thr, skipbotpix, printoutp, filtering):
    '''
    Main process for pre-screening based on photo blurriness
    '''
    # intialize variables based on directory and update cwd to indir
    cwd = os.getcwd()
    ind = os.path.join(cwd, indir)
    os.chdir(ind)
    nme = indir#.split('_')[0]
    foutn = '1_blurscreen_{0}.csv'.format(nme)
    fin = [f for f in os.listdir('.') if f.startswith('0_hourscreen') and f.endswith('.csv') and not f.endswith('_bad.csv')][0]

    # import list of photos (generated by 0_hourscreen)
    xx = pd.read_csv(fin, index_col=0, parse_dates=True)
    
    # did xx.index import as an object instead of a datetime?
    # xx.index = pd.to_datetime(xx.index, format = '%Y-%m-%d %H:%M:%S')
    # xx.index = pd.to_datetime(xx.index, format = '%Y-%m-%d %H:%M:%S.%f')
    # xx.index = pd.to_datetime(xx.index, format = '%m/%d/%Y %H:%M')
        
    # initialize variables needed for processing
    inf = xx['file'].to_list()
    infn = len(inf)
    badimg,b1l, b2l = [], [], []
    
    # process each requested photo
    for num, val in enumerate(inf):
        print('Working on file {0}, {1} out of {2}'.format(val, num+1, infn))
        
        # load image bands, truncating bottom text if needed
        arr0 = imageio.imread(val)
        arr1 = arr0[:-skipbotpix,:]
        
        # rescale image and convert to greyscale
        arr = rescale(arr1,0.25,channel_axis=-1,anti_aliasing=True) 
        #arr = rescale(arr1,0.25,multichannel=True,anti_aliasing=True) 
        arr = img_as_ubyte(arr)
        blur = rgb2gray(arr)
        
        # quantify blurriness
        edge_laplace = laplace(blur,ksize=3)
        b1 = variance(edge_laplace)
        b2 = np.amax(edge_laplace)
        b1l.append(b1)
        b2l.append(b2)
        
        # print progress if requested
        if printoutp == 1:
            print('b1 is {0}, b2 is {1}'.format(np.round(b1,3), np.round(b2,3)))
        
        # filter out blurry images if requested
        if filtering == 1:
            if b1 < b1thr or b2 < b2thr:
                if printoutp == 1:
                    print('b1 or b2 too low. need b1 >= {0}, b2 >= {1}'.format(b1thr, b2thr))
                badimg.append(val)

    # subset to list of acceptable images
    goodimg = sorted(list(set(inf)-set(badimg)))
    
    # add computed parameters to table of photo details
    xx['b1'] = b1l
    xx['b2'] = b2l
    yy = xx[xx['file'].isin(goodimg)].copy()
    
    # save output if necessary
    if len(yy['file'].to_list()) > 0:
        yy.to_csv(foutn)
    else:
        print('no new files meeting filter condition. Unless -f 0, no output will be written.')
    
if __name__ == '__main__':

    inps = cmdLineParse() # parse command line inputs
    blurscreen(inps.indir, inps.scaleimg, inps.b1thr, inps.b2thr, 
               inps.skipbotpix, inps.printoutp, inps.filtering) # run main program

